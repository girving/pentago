// Fast subset counting, indexing, and generation
#pragma once

#include "subsets_c.h"
#include "../base/board_c.h"
#include "../high/board.h"
#include "../utility/metal.h"
NAMESPACE_PENTAGO

// Precompute some combinations, and store in a triangular array.  Generated by
//   '{%s}'%','.join('{%s}'%','.join(str(choose(n,k)) for k in range(10+1)) for n in range(18+1))
#ifdef __METAL_VERSION__
#define COMBINATIONS_HACK 1  // Dodge a metal compiler bug
#else
#define COMBINATIONS_HACK 0
#endif
METAL_GLOBAL uint16_t combinations[18+1][10+1+COMBINATIONS_HACK] = {{1,0,0,0,0,0,0,0,0,0,0},{1,1,0,0,0,0,0,0,0,0,0},{1,2,1,0,0,0,0,0,0,0,0},{1,3,3,1,0,0,0,0,0,0,0},{1,4,6,4,1,0,0,0,0,0,0},{1,5,10,10,5,1,0,0,0,0,0},{1,6,15,20,15,6,1,0,0,0,0},{1,7,21,35,35,21,7,1,0,0,0},{1,8,28,56,70,56,28,8,1,0,0},{1,9,36,84,126,126,84,36,9,1,0},{1,10,45,120,210,252,210,120,45,10,1},{1,11,55,165,330,462,462,330,165,55,11},{1,12,66,220,495,792,924,792,495,220,66},{1,13,78,286,715,1287,1716,1716,1287,715,286},{1,14,91,364,1001,2002,3003,3432,3003,2002,1001},{1,15,105,455,1365,3003,5005,6435,6435,5005,3003},{1,16,120,560,1820,4368,8008,11440,12870,11440,8008},{1,17,136,680,2380,6188,12376,19448,24310,24310,19448},{1,18,153,816,3060,8568,18564,31824,43758,48620,43758}};

METAL_INLINE __attribute__((const)) uint16_t fast_choose(const int n, const int k) {
  assert(unsigned(n)<=18 && unsigned(k)<=10);
  return combinations[n][k];
}

METAL_INLINE __attribute__((const)) int choose(const int n, const int k) {
  if (n<0 || k<0 || k>n)
    return 0;
  return fast_choose(n, min(k, n-k));
}

// A k-subset of [0,n-1], packed into 64-bit ints with 5 bits for each entry.
// I.e., the set {a < b < c} has value a|b<<5|c<<10.  We order sets in large-entry-major order;
// the first 3-set of 10 is {0,1,2}, followed by {0,1,3}, {0,2,3}, ....
METAL_INLINE __attribute__((const)) set_t subset(const int n, const int k, int index) {
  assert(unsigned(n) <= 18 && unsigned(k) <= 9);
  assert(unsigned(index) < fast_choose(n, k));
  set_t set = 0;
  for (int i = k-1; i >= 0; i--) {
    int j = i, base = 0;
    for (; j < n; j++) {
      int next = base + fast_choose(j, i);
      if (index < next) break;
      base = next;
    }
    set |= set_t(j) << 5*i;
    index -= base;
  }
  return set;
}

// Bitmask for the index-th subset
METAL_INLINE __attribute__((const)) uint32_t subset_mask(const sets_t sets, int index) {
  uint32_t mask = 0;
  for (int i = sets.k-1; i >= 0; i--) {
    int j = i, base = 0;
    for (; j < sets.n; j++) {
      int next = base + fast_choose(j, i);
      if (index < next) break;
      base = next;
    }
    mask |= 1<<j;
    index -= base;
  }
  return mask;
}

METAL_INLINE uint16_t subset_index(const sets_t sets, const set_t set) {
  uint16_t index = 0;
  for (int i = 0; i < sets.k; i++) {
    const int j = set>>5*i&0x1f;
    index += fast_choose(j, i+1);
  }
  return index;
}

METAL_INLINE sets_t make_sets(const int n, const int k) {
  return sets_t{n, k, choose(n, k)};
}

METAL_INLINE set_t get(const sets_t sets, const int index) {
  return subset(sets.n, sets.k, index);
}

METAL_INLINE empty_t make_empty(const high_board_t board) {
  empty_t e;
  const auto free = board.empty_mask();
  for (int i = 0; i < 18; i++)
    e.empty[i] = 0;
  int next = 0;
  for (int i = 0; i < 64; i++)
    if (free & side_t(1)<<i)
      e.empty[next++] = i;
  return e;
}

METAL_INLINE side_t side(METAL_CONSTANT const empty_t& e, const sets_t sets, const set_t set) {
  side_t s = 0;
  for (int i = 0; i < sets.k; i++)
    s |= side_t(1) << e.empty[set >> 5*i & 0x1f];
  return s;
}

METAL_INLINE side_t side(METAL_CONSTANT const empty_t& e, const sets_t sets, const int index) {
  return side(e, sets, get(sets, index));
}

END_NAMESPACE_PENTAGO
