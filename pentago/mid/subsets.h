// Fast subset counting, indexing, and generation
#pragma once

#include "pentago/mid/midengine.h"
#include "pentago/utility/wasm.h"
#ifdef __cplusplus
#include "pentago/utility/array.h"
#endif  // __cplusplus
NAMESPACE_PENTAGO

typedef struct sets_t_ {
  int n, k;
  int size;
} sets_t;

// List empty spots as bit indices into side_t
typedef struct empty_t_ {
  uint8_t empty[18];
} empty_t;

#ifdef __cplusplus

static inline uint16_t fast_choose(const int n, const int k) {
  // Precompute some combinations, and store in a triangular array.  Generated by
  //   '{%s}'%','.join('{%s}'%','.join(str(choose(n,k)) for k in range(10+1)) for n in range(18+1))
  static const uint16_t combinations[18+1][10+1] = {{1,0,0,0,0,0,0,0,0,0,0},{1,1,0,0,0,0,0,0,0,0,0},{1,2,1,0,0,0,0,0,0,0,0},{1,3,3,1,0,0,0,0,0,0,0},{1,4,6,4,1,0,0,0,0,0,0},{1,5,10,10,5,1,0,0,0,0,0},{1,6,15,20,15,6,1,0,0,0,0},{1,7,21,35,35,21,7,1,0,0,0},{1,8,28,56,70,56,28,8,1,0,0},{1,9,36,84,126,126,84,36,9,1,0},{1,10,45,120,210,252,210,120,45,10,1},{1,11,55,165,330,462,462,330,165,55,11},{1,12,66,220,495,792,924,792,495,220,66},{1,13,78,286,715,1287,1716,1716,1287,715,286},{1,14,91,364,1001,2002,3003,3432,3003,2002,1001},{1,15,105,455,1365,3003,5005,6435,6435,5005,3003},{1,16,120,560,1820,4368,8008,11440,12870,11440,8008},{1,17,136,680,2380,6188,12376,19448,24310,24310,19448},{1,18,153,816,3060,8568,18564,31824,43758,48620,43758}};
  assert(unsigned(n)<=18 && unsigned(k)<=10);
  return combinations[n][k];
}

static inline int choose(const int n, const int k) {
  if (n<0 || k<0 || k>n)
    return 0;
  return fast_choose(n, std::min(k, n-k));
}

// A k-subset of [0,n-1], packed into 64-bit ints with 5 bits for each entry.
// I.e., the set {a < b < c} has value a|b<<5|c<<10.  We order sets in large-entry-major order;
// the first 3-set of 10 is {0,1,2}, followed by {0,1,3}, {0,2,3}, ....
static __attribute__((const)) set_t subset(const int n, const int k, int index) {
  assert(unsigned(n) <= 18 && unsigned(k) <= 9);
  assert(unsigned(index) < fast_choose(n, k));
  set_t set = 0;
  for (int i = k-1; i >= 0; i--) {
    int j = i, base = 0;
    for (; j < n; j++) {
      int next = base + fast_choose(j, i);
      if (index < next) break;
      base = next;
    }
    set |= set_t(j) << 5*i;
    index -= base;
  }
  return set;
}

static inline sets_t make_sets(const int n, const int k) {
  return sets_t{n, k, choose(n, k)};
}

static inline set_t get(const sets_t& sets, const int index) {
  return subset(sets.n, sets.k, index);
}

// Allocate subsets on the stack
#define ALLOCA_SUBSETS(name, sets) \
  set_t name##_raw_[sets.size]; \
  for (int i_ = 0; i_ < sets.size; i_++) \
    name##_raw_[i_] = get(sets, i_); \
  const RawArray<const set_t> name(sets.size, name##_raw_);

static inline void init(empty_t& e, const high_board_t board) {
  NON_WASM_ASSERT(board.count() >= 18);
  const auto free = board.empty_mask();
  memset(e.empty, 0, sizeof(e.empty));
  int next = 0;
  for (int i = 0; i < 64; i++)
    if (free & side_t(1)<<i)
      e.empty[next++] = i;
}

static inline side_t side(const empty_t& e, const sets_t& sets, const set_t set) {
  side_t s = 0;
  for (int i = 0; i < sets.k; i++)
    s |= side_t(1) << e.empty[set >> 5*i & 0x1f];
  return s;
}

static inline side_t side(const empty_t& e, const sets_t& sets, const int index) {
  return side(e, sets, get(sets, index));
}

#endif  // __cplusplus
END_NAMESPACE_PENTAGO
