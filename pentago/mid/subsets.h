// Fast subset counting, indexing, and generation

#include "pentago/utility/array.h"
NAMESPACE_PENTAGO
namespace {  // Performance is very sensitive to inlining here

using std::min;

static inline uint16_t fast_choose(const int n, const int k) {
  // Precompute some combinations, and store in a triangular array.  Generated by
  //   '{%s}'%','.join('{%s}'%','.join(str(choose(n,k)) for k in range(10+1)) for n in range(18+1))
  static const uint16_t combinations[18+1][10+1] = {{1,0,0,0,0,0,0,0,0,0,0},{1,1,0,0,0,0,0,0,0,0,0},{1,2,1,0,0,0,0,0,0,0,0},{1,3,3,1,0,0,0,0,0,0,0},{1,4,6,4,1,0,0,0,0,0,0},{1,5,10,10,5,1,0,0,0,0,0},{1,6,15,20,15,6,1,0,0,0,0},{1,7,21,35,35,21,7,1,0,0,0},{1,8,28,56,70,56,28,8,1,0,0},{1,9,36,84,126,126,84,36,9,1,0},{1,10,45,120,210,252,210,120,45,10,1},{1,11,55,165,330,462,462,330,165,55,11},{1,12,66,220,495,792,924,792,495,220,66},{1,13,78,286,715,1287,1716,1716,1287,715,286},{1,14,91,364,1001,2002,3003,3432,3003,2002,1001},{1,15,105,455,1365,3003,5005,6435,6435,5005,3003},{1,16,120,560,1820,4368,8008,11440,12870,11440,8008},{1,17,136,680,2380,6188,12376,19448,24310,24310,19448},{1,18,153,816,3060,8568,18564,31824,43758,48620,43758}};
  assert(unsigned(n)<=18 && unsigned(k)<=10);
  return combinations[n][k];
}

static inline int choose(const int n, const int k) {
  if (n<0 || k<0 || k>n)
    return 0;
  return fast_choose(n, min(k, n-k));
}

// A k-subset of [0,n-1], packed into 64-bit ints with 5 bits for each entry.
// I.e., the set {a < b < c} has value a|b<<5|c<<10.  We order sets in large-entry-major order;
// the first 3-set of 10 is {0,1,2}, followed by {0,1,3}, {0,2,3}, ....
static __attribute__((const)) set_t subset(const int n, const int k, int index) {
  assert(unsigned(n) <= 18 && unsigned(k) <= 9);
  assert(unsigned(index) < fast_choose(n, k));
  set_t set = 0;
  for (int i = k-1; i >= 0; i--) {
    int j = i, base = 0;
    for (; j < n; j++) {
      int next = base + fast_choose(j, i);
      if (index < next) break;
      base = next;
    }
    set |= set_t(j) << 5*i;
    index -= base;
  }
  return set;
}

struct sets_t {
  const int n, k;
  const int size;

  sets_t(const int n, const int k) : n(n), k(k), size(choose(n, k)) {}
  set_t operator()(const int index) const { return subset(n, k, index); }
};

// Allocate subsets on the stack
#define ALLOCA_SUBSETS(name, sets) \
  set_t name##_raw_[sets.size]; \
  for (int i_ = 0; i_ < sets.size; i_++) \
    name##_raw_[i_] = sets(i_); \
  const RawArray<const set_t> name(sets.size, name##_raw_);

// List empty spots as bit indices into side_t
struct empty_t {
  uint8_t empty[18];

  empty_t(const high_board_t board) {
    NON_WASM_ASSERT(board.count() >= 18);
    const auto free = board.empty_mask();
    memset(empty, 0, sizeof(empty));
    int next = 0;
    for (int i = 0; i < 64; i++)
      if (free & side_t(1)<<i)
        empty[next++] = i;
  }

  side_t side(const sets_t& sets, const set_t set) const {
    side_t s = 0;
    for (int i = 0; i < sets.k; i++)
      s |= side_t(1) << empty[set >> 5*i & 0x1f];
    return s;
  }

  side_t side(const sets_t& sets, const int index) const {
    return side(sets, sets(index));
  }
};

}
END_NAMESPACE_PENTAGO
