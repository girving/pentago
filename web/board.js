// Pentago board operations

'use strict'

// Since javascript doesn't support 64 bit ints, we have to jump through some hoops.
// Quadrants are little endian (0 through 3).  The follow tables are generated by 'pentago/web/generate quadrants'
const digit_quadrants = [[1,0,0,0],[10,0,0,0],[100,0,0,0],[1000,0,0,0],[10000,0,0,0],[34464,1,0,0],[16960,15,0,0],[38528,152,0,0],[57600,1525,0,0],[51712,15258,0,0],[58368,21515,2,0],[59392,18550,23,0],[4096,54437,232,0],[40960,20082,2328,0],[16384,4218,23283,0],[32768,42182,36222,3],[0,28609,34546,35],[0,23946,17784,355],[0,42852,46771,3552]]
const bit_sections = [[1,0,0,0],[2,0,0,0],[4,0,0,0],[8,0,0,0],[16,0,0,0],[32,0,0,0],[64,0,0,0],[128,0,0,0],[256,0,0,0],[512,0,0,0],[1024,0,0,0],[2048,0,0,0],[4096,0,0,0],[8192,0,0,0],[16384,0,0,0],[32768,0,0,0],[65536,0,0,0],[31072,1,0,0],[62144,2,0,0],[24288,5,0,0],[48576,10,0,0],[97152,20,0,0],[94304,41,0,0],[88608,83,0,0],[77216,167,0,0],[54432,335,0,0],[8864,671,0,0],[17728,1342,0,0],[35456,2684,0,0],[70912,5368,0,0],[41824,10737,0,0],[83648,21474,0,0],[67296,42949,0,0],[34592,85899,0,0],[69184,71798,1,0],[38368,43597,3,0],[76736,87194,6,0],[53472,74389,13,0],[6944,48779,27,0],[13888,97558,54,0],[27776,95116,109,0],[55552,90232,219,0],[11104,80465,439,0],[22208,60930,879,0],[44416,21860,1759,0],[88832,43720,3518,0],[77664,87441,7036,0],[55328,74883,14073,0],[10656,49767,28147,0],[21312,99534,56294,0],[42624,99068,12589,1],[85248,98136,25179,2],[70496,96273,50359,4],[40992,92547,719,9],[81984,85094,1439,18],[63968,70189,2879,36],[27936,40379,5759,72],[55872,80758,11518,144],[11744,61517,23037,288],[23488,23034,46075,576],[46976,46068,92150,1152],[93952,92136,84300,2305],[87904,84273,68601,4611],[75808,68547,37203,9223]]
const win_rays = [[0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],[0,1],[1,1],[6,1],[7,1],[12,1],[13,1],[18,1],[19,1],[24,1],[25,1],[30,1],[31,1],[4,5],[5,5],[10,5],[11,5],[0,7],[1,7],[6,7],[7,7]]

// Pull in math
const floor = Math.floor
const min = Math.min
const pow = Math.pow
const abs = Math.abs

function str_to_quadrants(s) {
  // We assume s consists entirely of digits
  if (!s.match(/^\d+$/) || s.length>19)
    throw 'expected number < 5540271966595842048, got '+s
  // Accumulate into base 2**16, ignoring overflow
  const quads = [0,0,0,0]
  for (let i=0;i<s.length;i++) {
    const d = parseInt(s[s.length-1-i])
    for (let a=0;a<4;a++)
      quads[a] += d*digit_quadrants[i][a]
  }
  // Reduce down to base 2**16
  for (let i=0;i<3;i++) {
    quads[i+1] += quads[i]>>16
    quads[i] &= (1<<16)-1
  }
  if (quads[3]>=(1<<16))
    throw 'expected number < 5540271966595842048, got '+s
  return quads
}

function quadrants_to_str(quads) {
  // Accumulate into base 10**5, ignoring overflow
  const sections = [0,0,0,0]
  for (let b=0;b<64;b++)
    if (quads[b>>4]&1<<(b&15)) 
      for (let a=0;a<4;a++)
        sections[a] += bit_sections[b][a]
  // Reduce down to base 10**5
  let s = ''
  for (let i=0;i<3;i++) {
    sections[i+1] += floor(sections[i]/100000)
    const si = '00000'+sections[i]%100000
    s = si.substr(si.length-5)+s
  }
  s = sections[3]+s
  return s.substr(min(s.match(/^0*/)[0].length,s.length-1))
}

// Mirror of high_board_t in python
// Usage: board_t(quadrants,middle) or board_t(name)
// Examples: board_t([1,0,0,0],true), board_t('1m')
function board_t() {
  let name, quads, middle
  if (arguments.length == 1) {
    name = arguments[0]
    const m = name.match(/^(\d+)(m?)$/)
    if (!m)
      throw 'invalid board '+arguments[0]
    quads = str_to_quadrants(m[1])
    middle = m[2].length
  } else if (arguments.length==2) {
    quads = arguments[0]
    middle = arguments[1]
    if (quads.length != 4 || (middle != 0 && middle != 1))
      throw 'invalid board: quads '+quads+', middle '+middle
    name = quadrants_to_str(quads)+(middle?'m':'')
  } else
    throw 'expected (quadrants,middle) or (name), got '+arguments
  this.quads = quads
  this.middle = middle
  this.name = name

  // Extract grid
  const grid = Array(36)
  for (let qx=0;qx<2;qx++)
    for (let qy=0;qy<2;qy++) {
      let quad = quads[2*qx+qy]
      for (let x=0;x<3;x++)
        for (let y=0;y<3;y++) {
          grid[6*(3*qx+x)+3*qy+y] = quad%3
          quad = floor(quad/3)
        }
    }
  this.grid = grid

  // Count stones 
  let count0 = 0
  let count1 = 0
  for (let i=0;i<36;i++) {
    count0 += grid[i]==1
    count1 += grid[i]==2
  }
  const count = count0+count1
  this.count = count
  const turn = (count0-1==count1-middle)+0
  this.turn = turn
  if (count0-turn-middle*(turn==0)!=count1-middle*(turn==1))
    throw 'bad board: quads '+quads+', middle '+middle+', turn '+turn+', counts '+count0+' '+count1

  // Place a stone at the given location
  const place = this.place = (x, y) => {
    if (middle || grid[6*x+y])
      throw 'bad place: '+name+', xy '+x+' '+y
    const qm = quads.slice(0)
    qm[2*floor(x/3)+floor(y/3)] += (1+turn)*pow(3,3*(x%3)+y%3)
    return new board_t(qm,true)
  }

  // Rotate the given quadrant left (d=1) or right (d=-1)
  const rotate = this.rotate = (qx, qy, d) => {
    if (!middle || !(qx==0 || qx==1) || !(qy==0 || qy==1) || abs(d)!=1)
      throw 'bad rotate: '+name+', middle '+middle+', q '+qx+' '+qy+', d '+d
    let quad = 0
    for (let x=2;x>=0;x--)
      for (let y=2;y>=0;y--)
        quad = 3*quad+grid[6*(3*qx+1+d*(y-1))+3*qy+1-d*(x-1)]
    const qm = quads.slice(0)
    qm[2*qx+qy] = quad
    return new board_t(qm, false)
  }

  // Does the given side have 5 in a row?
  const won = side => {
    const v = side+1
    for (let i=0;i<win_rays.length;i++) {
      const s = win_rays[i][0]
      const d = win_rays[i][1]
      if (grid[s]==v && grid[s+d]==v && grid[s+2*d]==v && grid[s+3*d]==v && grid[s+4*d]==v)
        return true
    }
    return false
  }

  // Start and end for each five in a row
  this.fives = () => {
    function coord(i) { const x = floor(i/6); return [x,i-6*x] }
    const fives = []
    for (let i=0;i<win_rays.length;i++) {
      const s = win_rays[i][0]
      const d = win_rays[i][1]
      const v = grid[s]
      if (v && grid[s+d]==v && grid[s+2*d]==v && grid[s+3*d]==v && grid[s+4*d]==v)
        fives.push([coord(s), coord(s+d), coord(s+2*d), coord(s+3*d), coord(s+4*d)])
    }
    return fives
  }

  // Is the game over?
  this.done = () => won(0) || won(1) || (count==36 && !middle)

  // Assuming the game is over, what is the current player's results?  1=win, 0=tie, -1=loss
  this.immediate_value = () => {
    const win = won(turn)
    const lose = won(1-turn)
    if (win || lose)
      return win && lose ? 0 : win ? 1 : -1
    if (count==36)
      return 0
    throw 'board '+name+': immediate_value() called when board isn\'t done'
  }

  // List moves
  this.moves = () => {
    const moves = []
    if (!middle) {
      for (let x=0;x<6;x++)
        for (let y=0;y<6;y++)
          if (!grid[6*x+y])
            moves.push(place(x,y))
    } else
      for (let qx=0;qx<2;qx++)
        for (let qy=0;qy<2;qy++)
          for (let d=-1;d<=1;d+=2)
            moves.push(rotate(qx,qy,d))
    return moves
  }
}

// Export the board type
exports.board_t = board_t
