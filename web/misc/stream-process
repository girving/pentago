#!/usr/bin/env python3

import json
import re
import subprocess
import sys

# Parse hashes generated by stream-hashes
data = {}
for line in open('blah'):
  if 'name' in line:
    j = json.loads(line)
    data[j['name']] = j

# Parse known hashes out of hashes.js
known = {}
sha1_re = re.compile(r'^\s+([0-9a-f]{40})\s+(\S+)\s*$')
for line in open('hashes.js'):
  m = sha1_re.match(line)
  if m:
    known[m.group(2)] = m.group(1)

# Parse sizes out of git
sizes = {}
cmd = 'git', 'show', 'edison-final'
ls_re = re.compile(r'.*girving\s+m1302\s+(\d+).{14}(\S+)$')
for line in subprocess.check_output(cmd).decode().split('\n'):
  m = ls_re.match(line)
  if m:
    sizes[m.group(2)] = int(m.group(1))

# Sort small numbers first, even if they fewer digits
number_pat = re.compile(r'\d+')
def numeric_key(s):
  return number_pat.sub(lambda m: '%07d' % int(m.group(0)), s)

js = {}
js_chunks = {}
chunk_re = re.compile(r'^slice-\d+\.pentago\.\d+$')
for name in sorted(data.keys(), key=numeric_key):
  j = data[name]
  md5 = j['md5']
  sha1 = j['sha1']
  chunk = bool(chunk_re.match(name))
  assert (name not in known) == (chunk or name.endswith('.pentago.index')), (name, chunk)
  if name in known:
    assert known[name] == sha1
  if 0:
    print(f"{name}: md5 {md5}", file=sys.stderr)
  j = j.copy()
  del j['name']
  if 'size' not in j:
    j['size'] = sizes[name]
  if chunk:
    js_chunks[name] = j
  else:
    js[name] = j

with open('metadata.json', 'w') as f:
  print(json.dumps(js, indent=2), file=f)
with open('metadata-chunks.json', 'w') as f:
  print(json.dumps(js_chunks, indent=2), file=f)
