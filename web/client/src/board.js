// Pentago board operations

// Generated by pentago/web/client/py/generate
const win_rays = [[0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],[0,1],[1,1],[6,1],[7,1],[12,1],[13,1],[18,1],[19,1],[24,1],[25,1],[30,1],[31,1],[4,5],[5,5],[10,5],[11,5],[0,7],[1,7],[6,7],[7,7]]

// Pull in math
const floor = Math.floor
const min = Math.min
const abs = Math.abs

// Usage: new board_t(stones,middle), parse_board(name)
// Examples: new board_t([1,0,0,0],true), parse_board('1m')
function board_t(grid, middle) {
  this.grid = grid
  this.middle = middle

  // Count stones, compute name
  let stones = 0n
  let count0 = 0
  let count1 = 0
  for (let i = 0n; i < 36n; i++) {
    const x = i / 6n
    const y = i % 6n
    const s = BigInt(grid[i])
    stones += s * 3n**(x % 3n * 3n + y % 3n) << (16n * (x / 3n * 2n + y / 3n))
    count0 += s == 1
    count1 += s == 2
  }
  const name = this.name = stones + (middle ? 'm' : '')
  this.raw = stones | BigInt(middle) << 63n
  const count = this.count = count0 + count1
  const turn = this.turn = (count0-1 == count1-middle)+0

  // Check validity
  if (count0-turn-middle*(turn==0) != count1-middle*(turn==1))
    throw Error('bad board '+name+': turn '+turn+', counts '+count0+' '+count1)

  // Place a stone at the given location
  const place = this.place = (x, y) => {
    if (middle || grid[6*x+y])
      throw Error('bad place: '+name+', xy '+x+' '+y)
    const g = grid.slice()
    g[6*x+y] = 1 + turn
    return new board_t(g, true)
  }

  // Rotate the given quadrant left (d=1) or right (d=-1)
  const rotate = this.rotate = (qx, qy, d) => {
    if (!middle || !(qx==0 || qx==1) || !(qy==0 || qy==1) || abs(d)!=1)
      throw Error('bad rotate: '+name+', q '+qx+' '+qy+', d '+d)
    const g = grid.slice()
    for (let x = 0; x < 3; x++)
      for (let y = 0; y < 3; y++)
        g[6*(3*qx + x) + 3*qy + y] = grid[6*(3*qx + 1 + d*(y-1)) + 3*qy + 1 - d*(x-1)]
    return new board_t(g, false)
  }

  // Does the given side have 5 in a row?
  const won = side => {
    const v = side + 1
    for (const r of win_rays) {
      const s = r[0]
      const d = r[1]
      if (grid[s]==v && grid[s+d]==v && grid[s+2*d]==v && grid[s+3*d]==v && grid[s+4*d]==v)
        return true
    }
    return false
  }

  // Start and end for each five in a row
  this.fives = () => {
    const coord = (i) => [floor(i/6), i%6]
    const fives = []
    for (const r of win_rays) {
      const s = r[0]
      const d = r[1]
      const v = grid[s]
      if (v && grid[s+d]==v && grid[s+2*d]==v && grid[s+3*d]==v && grid[s+4*d]==v)
        fives.push([coord(s), coord(s+d), coord(s+2*d), coord(s+3*d), coord(s+4*d)])
    }
    return fives
  }

  // Is the game over?
  this.done = won(0) || won(1) || (count==36 && !middle)
  if (this.done)
    this.immediate_value = won(turn) - won(1-turn)

  // List moves
  this.moves = () => {
    const moves = []
    if (!middle) {
      for (let x=0;x<6;x++)
        for (let y=0;y<6;y++)
          if (!grid[6*x+y])
            moves.push(place(x,y))
    } else
      for (let qx=0;qx<2;qx++)
        for (let qy=0;qy<2;qy++)
          for (let d=-1;d<=1;d+=2)
            moves.push(rotate(qx,qy,d))
    return moves
  }
}

// Convert from canonical board name or raw_t
export function parse_board(name) {
  const m = (name + '').match(/^(\d+)(m?)$/)
  if (!m)
    throw Error('Invalid board ' + name)

  // Extract grid
  const stones = BigInt(m[1])
  const grid = Array(36)
  for (let i = 0n; i < 36n; i++) {
    const x = i / 6n
    const y = i % 6n
    grid[i] = Number((stones >> 16n*(x / 3n * 2n + y / 3n)) % 32768n / 3n**(3n*(x % 3n) + y % 3n) % 3n)
  }

  // middle if we have an 'm', or the raw_t middle bit is set
  return new board_t(grid, m[2].length || stones >> 63n != 0)
}
