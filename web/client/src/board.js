// Pentago board operations

// Generated by pentago/web/client/py/generate
const win_rays = [[0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],[0,1],[1,1],[6,1],[7,1],[12,1],[13,1],[18,1],[19,1],[24,1],[25,1],[30,1],[31,1],[4,5],[5,5],[10,5],[11,5],[0,7],[1,7],[6,7],[7,7]]

// Pull in math
const floor = Math.floor
const min = Math.min
const pow = Math.pow
const abs = Math.abs

function str_to_quadrants(s) {
  // We assume s consists entirely of digits
  if (s.match(/^\d+$/) && s.length<=19) {
    // Accumulate into base 2**16, ignoring overflow
    const quads = [0,0,0,0]
    for (let i = 0; i < s.length; i++) {
      const d = parseInt(s[s.length-1-i])
      for (let q = 0; q < 4; q++)
        quads[q] += (floor(pow(5, i) * pow(2, i-16*q)) & 0xffff) * d
    }
    // Reduce down to base 2**16
    for (let q = 0; q < 3; q++) {
      quads[q+1] += quads[q] >> 16
      quads[q] &= 0xffff
    }
    if (quads[3] <= 0xffff)
      return quads
  }
  throw Error('expected number < 5540271966595842048, got '+s)
}

function quadrants_to_str(quads) {
  // Accumulate into base 10**5, ignoring overflow
  const sections = [0,0,0,0]
  for (let b = 0; b < 64; b++)
    if (quads[b>>4] & 1<<(b&15))
      for (let a = 0; a < 4; a++)
        sections[a] += floor(pow(2, b-5*a) / pow(5, 5*a)) % 100000
  // Reduce down to base 10**5
  let s = ''
  for (let i = 0; i < 3; i++) {
    sections[i+1] += floor(sections[i] / 100000)
    const si = '00000' + sections[i] % 100000
    s = si.substr(si.length-5)+s
  }
  s = sections[3]+s
  return s.substr(min(s.match(/^0*/)[0].length,s.length-1))
}

// Mirror of high_board_t in python
// Usage: board_t(quadrants,middle) or board_t(name)
// Examples: board_t([1,0,0,0],true), board_t('1m')
function board_t() {
  let name, quads, middle
  if (arguments.length == 1) {
    name = arguments[0]
    const m = name.match(/^(\d+)(m?)$/)
    if (!m)
      throw Error('Invalid board ' + name)
    quads = str_to_quadrants(m[1])
    middle = m[2].length
  } else if (arguments.length==2) {
    quads = arguments[0]
    middle = arguments[1]
    if (quads.length != 4 || (middle != 0 && middle != 1))
      throw Error('invalid board: quads '+quads+', middle '+middle)
    name = quadrants_to_str(quads)+(middle?'m':'')
  } else
    throw Error('expected (quadrants,middle) or (name), got '+arguments)
  this.quads = quads
  this.middle = middle
  this.name = name

  // Extract grid
  const grid = Array(36)
  for (let qx=0;qx<2;qx++)
    for (let qy=0;qy<2;qy++) {
      let quad = quads[2*qx+qy]
      for (let x=0;x<3;x++)
        for (let y=0;y<3;y++) {
          grid[6*(3*qx+x)+3*qy+y] = quad%3
          quad = floor(quad/3)
        }
    }
  this.grid = grid

  // Count stones 
  let count0 = 0
  let count1 = 0
  for (let i=0;i<36;i++) {
    count0 += grid[i]==1
    count1 += grid[i]==2
  }
  const count = count0+count1
  this.count = count
  const turn = (count0-1==count1-middle)+0
  this.turn = turn
  if (count0-turn-middle*(turn==0)!=count1-middle*(turn==1))
    throw Error('bad board: quads '+quads+', middle '+middle+', turn '+turn+', counts '+count0+' '+count1)

  // Place a stone at the given location
  const place = this.place = (x, y) => {
    if (middle || grid[6*x+y])
      throw Error('bad place: '+name+', xy '+x+' '+y)
    const qm = quads.slice(0)
    qm[2*floor(x/3)+floor(y/3)] += (1+turn)*pow(3,3*(x%3)+y%3)
    return new board_t(qm,true)
  }

  // Rotate the given quadrant left (d=1) or right (d=-1)
  const rotate = this.rotate = (qx, qy, d) => {
    if (!middle || !(qx==0 || qx==1) || !(qy==0 || qy==1) || abs(d)!=1)
      throw Error('bad rotate: '+name+', middle '+middle+', q '+qx+' '+qy+', d '+d)
    let quad = 0
    for (let x=2;x>=0;x--)
      for (let y=2;y>=0;y--)
        quad = 3*quad+grid[6*(3*qx+1+d*(y-1))+3*qy+1-d*(x-1)]
    const qm = quads.slice(0)
    qm[2*qx+qy] = quad
    return new board_t(qm, false)
  }

  // Does the given side have 5 in a row?
  const won = side => {
    const v = side+1
    for (let i=0;i<win_rays.length;i++) {
      const s = win_rays[i][0]
      const d = win_rays[i][1]
      if (grid[s]==v && grid[s+d]==v && grid[s+2*d]==v && grid[s+3*d]==v && grid[s+4*d]==v)
        return true
    }
    return false
  }

  // Start and end for each five in a row
  this.fives = () => {
    function coord(i) { const x = floor(i/6); return [x,i-6*x] }
    const fives = []
    for (let i=0;i<win_rays.length;i++) {
      const s = win_rays[i][0]
      const d = win_rays[i][1]
      const v = grid[s]
      if (v && grid[s+d]==v && grid[s+2*d]==v && grid[s+3*d]==v && grid[s+4*d]==v)
        fives.push([coord(s), coord(s+d), coord(s+2*d), coord(s+3*d), coord(s+4*d)])
    }
    return fives
  }

  // Is the game over?
  this.done = () => won(0) || won(1) || (count==36 && !middle)

  // Assuming the game is over, what is the current player's results?  1=win, 0=tie, -1=loss
  this.immediate_value = () => {
    const win = won(turn)
    const lose = won(1-turn)
    if (win || lose)
      return win && lose ? 0 : win ? 1 : -1
    if (count==36)
      return 0
    throw Error('board '+name+': immediate_value() called when board isn\'t done')
  }

  // List moves
  this.moves = () => {
    const moves = []
    if (!middle) {
      for (let x=0;x<6;x++)
        for (let y=0;y<6;y++)
          if (!grid[6*x+y])
            moves.push(place(x,y))
    } else
      for (let qx=0;qx<2;qx++)
        for (let qy=0;qy<2;qy++)
          for (let d=-1;d<=1;d+=2)
            moves.push(rotate(qx,qy,d))
    return moves
  }
}

// Export the board type
export { board_t as default }
